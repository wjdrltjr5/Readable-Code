# Readable Code
# 추상

## 추상과 구체

## 이름 짓기

이 코드의 내용을 추상화한 이름을 짓자

## 메서드와 추상화

추상화 되는 의미가 있는가.

## 메서드 선언부

메서드 선언부에도 많은 정보를 주기에 신경써서 작성하자

## 추상화 레벨

주변과 추상화 레벨을 맞추자

## 매직넘버, 매직 스트링

상수 이런 것 들 분리하자

# 논리 사고의 흐름

## Early return

```java
extracted();
void extracted(){
	if(a>3){
		doSometing1();
		return;
	}
	
	if(a<=3 && b > 1) {
		doSometing2();
		return;
	}
}
//else의 사용을 지양하자 굳이써야하나 얼리리턴을 사용하면 가독성이 더 좋다.
```

## 사고의 depth 줄이기

### 중첩 분기문, 중첩 반복문

```java
for(int i = 0; i < 20; i++){
	for(int j = 20; j < 30; j++){
		if( i >= 10 && j < 25) {
			doSomething();
		}
	}
}
------------------------------------
for(int i = 0; i <20; i++){
	doSomethingWithI(i)
}

private void doSomethingWithI(int i ){
	for(int j = 20; j < 30; j++){
		doSomethingIJ(i,j);
	}
}

private void doSomethingWithIJ(int i, int j){
	if(i>= 10 && j < 25){	
		doSomething()
	}
}
```

무조건 1depth로 만들어라 x

추상화로 사고 과정을 줄일 수 있다면 사용

2중 중첩이 더 도움이 된다면 그대로 나둬야 함

stream사용

메서드 리팩토링할때 원본 복사한후 리팩토링 이상없으면 적용

### 사용할 변수는 가깝게 선언하기

이건 클린 코드에도 나왔던 내용 지역변수는 사용직전에 선언 내부에 메서드사용시 그 메서드는 바로 다음에 정의

## 공백 라인도 의미를 가진다

복잡한 로직의 의미 단위를 나누어 보여줌으로써 가독성을 높인다.

## 부정어를 대하는 자세

```java
    if(!isLeftDirection()){
        doSometing();
    }
    -------------------------
    if(isRightDirection()) 	doSometing();
    if(isNotLeftDircetion()) 	doSometing();
```

! 부정연산자는 가독성이 나쁘고 사고가 두번 일어나게됨

- 부정어구를 쓰지 않아도 되는 상황인치 체크
- 부정의 의미를 담은 다른 단어가 존재하는지 고민 or 부정어구로 메서드 구성(not)

## 해피케이스와 예외처리

- 예외가 발생할 가능성 낮추기
- 어떤 값이 검증이 필요한 부분은 주로 외부 세계와의 접점
    - 사용자 입력, 객체 생성자, 외부 서버의 요청 등
- 의도한 예외와 예상하지 못한 예외를 구분하기
    - 사용자에게 보여줄 예외와, 개발자가 보고 처리해야할 예외 구분


### Null을 대하는 자세

- 항상 NullPointException을 방지하는 방향으로 경각심을 가지기

- 메서드 설계시 return null을 자제한다.
    - 어렵다면 Optional 사용을 고민


### Optional에 관하여

- Optional은 비싼 객체다. 꼭 필요한 상황에서 반환 타입에 사용한다.
- Optional을 파라미터로 받지 않도록 한다. 분기 케이스가 3개나 된다.
    - Optional이 가진 데이터가 null인지 아닌지, optional 그 자체가 null인지
- Optional을 반환 받았다면 최대한 빠르게 해소한다.
- 분기문을 만드는 isPresent()-get()대신 풍부한 API사용
    - orElseGet(), orElseThrow(), isPresent(), ifPresentOrElse()  null인경우 실행/ orElse()는 호출할 필요가 없는 경우에도 항상 실행 주의 확정된 값일때 사용
    - orElse(), orElseGet(). orElseThrow()의 차이 숙지


객체.eqals(상수) ⇒ 널위험이 있음 왜? 객체가 null일 수 있으니까  상수.equals(객체는) 괜찮음 상수는 항상 있으니까

## 객체지향 패러다임

객체가 제공하는 것

- 절차 지향에서 잘 보이지 않았던 개념을 가시화
- 관심사가 한 군데로 모이기 때문에, 유지보수성 좋아짐
- 여러 객체를 사용하는 입장에서는 구체적인 구현에 신경 쓰지 않고 보다 높은 추상화 레벨에서 도메인 로직을 다룰 수 있다.
- 유효성 검증이 가능

객체생성시 주의점

- 1개의 관심사로 명확하게 책임이 정의되었는지 확인하기
- 메서드를 추상화할 때와 비슷하다.
- 객체를 만듦으로써 외부 세계와 어떤 소통을 하려고 하는지 생각해보자
- Setter 사용 자제
    - 데이터는 불변이 최고다. 변하는 데이터라도 객체가 핸들링할 수 있어야 한다.
    - 객체 내부에서 외부 세계의 개입 없이 자체적인 변경/ 가공으로 처리할 수 있는지를 확인
    - 만약 외부에서 가지고 있는 데이터로 데이터 변경요청을 해야 하는 경우 의도를 드러내는 네이밍 고려
- Getter
    - getter도 처음에는 사용 자제 반드시 필요한 경우에 추가하기
    - 외부에서 객체 내 데이터가 필요하다고 getter를 남발하는 것은 무례한 행동
    - 객체에 메시지를 보내라
    - 캡슐화 되어있는 데이터를 외부에서 안다고 가정하면 안됨 ex. 자바 컬렉션 사용할때 필드를 알고있는가? 그냥 행위를 아는거지

    ```java
    Person person = new Person();
    //1
    if(person.get지갑().get신분증().findAge() >= 19){
    	pass()
    }
    
    //2
    if(person.isAgeGreaterThanOrEqualTo(19)){
    	pass()
    }
    ```

- 필드의 수는 적을수록 좋다.
    - 불필요한 데이터가 많을수록 복잡도가 높아지고 대응할 변화가 많아진다.
    - ex. totalPrice 필드보다는 stream().mapToLong(Menu::getPrcie).sum();
    - 성능상 이점이 있다면 그냥 필드를 사용


- 행위의 주체를 생각하자

## SOLID

- SRP
    - 하나의 클래스는 한 가지의 변경 이유만을 가져야 한다. (책임)
    - 관심사의 분리
    - 높은 응집도, 낮은 결합도
    - 책임을 볼 줄 아는 눈을 가지자 (오브젝트, 객체지향의 사실과 오해)
- OCP
    - 확장에는 열려있고, 수정에는 닫혀있어야 한다.(기존 코드의 변경없이 시스템의 기능을 확장할 수 있어야 한다.)
    - 추상화와 다형성을 활용해서 OCP를 지킬 수 있다.
- LSP
    - 상속 구조에서 부모 클래스의 인스턴스를 자식 클래스의 인스턴스로 치환할 수 있어야 한다.
- ISP
    - 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하면 안된다.
    - 인터페이스를 잘게 쪼개라
- DIP
    - 상위 수준의 모듈은 하위수준의 모듈에서 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다. 상위(잘 바뀌지 않는것 ,추상화) 하위(잘 바뀌는 것, 구체)

## 객체 지향 적용하기

### 상속과 조합

- 상속보다는 조합을 사용하자.
- 상속은 시멘트처럼 굳어지는 구조다 수정이 어렵다(부모와 자식의 결합도가 높다)
- 조합과 인터페이스를 활용하는 것이 유연한 구조
    - 상속을 통한 코드의 중복 제거가 주는 이점보다, 중복이 생기더라도 유연한 구조 설계가 주는 이점이 크다


### Value object

- 도메인의 어떤 개념을 추상화하여 표현한 값 객체
- 값으로 취급하기 위해서, 불변성, 동등성 유효성 검증 등을 보장해야 한다.
    - 불변성 : final필드, setter금지
    - 동등성 : 서로 다른 인스턴스여도 (동일성이 달라도) 내부의 값이 같으면 같은 값 객체로 취급한다. equals() & hashCode() 재정의 필요
    - 유효성 검증 : 객체가 생성되는 시점에 값에 대한 유효성을 보장하기

### VO vs Entity

식별자 여부 엔티티의 경우 식별자가 같은데 식별자가 아닌 필드의 값이 서로 다른 두 인스턴스가 있다면 같은 Entity가 시간이 지남에 따라 변화한 것으로 볼 수 있다.

### 일급 컬렉션

일급 시민

- 다른 요소에게 사용 가능한 모든 연산을 지원하는 요소
    - 변수로 할당될 수 있다.
    - 파라미터로 전달될 수 있다.
    - 함수의 결과로 반환될 수 있다.


일급 함수

- 함수형 프로그래밍 언어에서, 함수는 일급 시민이다. 함수는 변수에 할당될 수 있고, 인자로 전달될 수 있고 함수의 결과로 함수가 반환될 수 있다.

일급 컬렉션

- 컬렉션을 포장하면서, 컬렉션만을 유일하게  필드로 가지는 객체
    - 컬렉션을 다른 객체와 동등한 레벨로 다루기 위함
    - 단 하나의 컬렉션 필드만을 가진다.
- 컬렉션을 추상화하며 의미를 담을 수 있고, 가공 로직의 보금자리가 생긴다.
    - 가공 로직에 대한 테스트도 작성할 수 있다.
- 만약 getter로 컬렉션을 반환할 일이 생긴다면 외부 조작을 피하기 위해 꼭 새로운 컬렉션으로 만들어서 반환해주자(중요!)

### Enum의 특성과 활용

- Enum은 상수의 집합이며, 상수와 관련된 로직을 담을 수 있는 공간이다.
    - 상태와 행위를 한 곳에서 관리할 수 있는 추상화된 객체
- 특정 도메인 개념에 대해 그 종류와 기능을 명시적으로 표현해 줄 수 있다.
- 만약 변경이 정말 잦은 개념은 Enum보다 DB로 관리하는 것이 나을 수 있다.

### 숨겨져 있는 도메인 개념 도출하기

- 도메인 지식은 만드는 것이 아니라 발견하는 것
- 객체 지향은 현실의 100% 반영하는 도구가 아니라, 흉내내는 것이다.
    - 현실 세계에서 쉽게 인지하지 못하는 개념도 도출해서 사용해야 할 때가 있다. (오브젝트 내용)
- 설계할 때는 근시적, 거시적 관점에서 최대한 미래를 예측하고, 시간이 지나 만약 틀렸다는 것을 인지하면 언제든 돌아올 수 있도록 코드를 만들어야 한다.
    - 완벽한 설계는 없다 그당시에 최선이 있을 뿐

### 주석의 양면성

- 주석은 죄악 vs 주석 좀 남겨줘라
- 주석이 많다는 것은 코드로 잘 표현을 하지 못했다는 의미
- 후대에 전해야할 의사 결정의 히스토리를 코드로 표현할 수 없을때 주석으로 상세하게 설명(이런 정책 선정의 이유)
- 주석 작성시 자주 변하는 정보는 최대한 지양
- 코드 업데이트시 당연히 문서도 업데이트

### 변수와 메서드의 나열 순서

- 변수
    - 사용하는 순서대로 나열
- 메서드의 순서 객체의 입장에서 생각



### 패키지 나누기

- 패키지는, 문맥으로써의 정보를 제공할 수 있다.
- 패키지를 쪼개지 않으면 관리가 어려워진다.
- 패키지를 너무 잘게 쪼개도 마찬가지로 관리가 어려워진다.

## 리팩토링 포인트

- 추상화 레벨
- 객체로 묶어볼만한 것은 없는지
- 객체지향 패러다임에 맞게 객체들이 상호 협력하고 있는지
- SRP : 책임에 따라 응집도 있게 객체가 잘 나뉘어져 있는지
- DIP : 의존관계 역전을 적용할 만한 곳은 없는지
- 일급 컬렉션

## 기억하면 좋은 조언들

### 관점의 차이로 달라지는 추상화

- 방식 x 어떤걸 필요로 하는가 방법은 관심사가 아니다.

### 능동적 읽기

- 복잡하거나 엉망인 코드를 일고 이해하려 할 때, 리팩토링 하면서 읽기
    - 공백으로 단락 구분하기
    - 메서드와 객체로 추상화 해보기
    - 주석으로 이해한 내용 표기하며 읽기
- 언제든 돌아갈 수 있는 git reset —hard 가 있다.
- 핵심 목표는 우리의 도메인 지식을 늘리는 것. 그리고 이전 작성자의 의도를 파악하는 것.

### 오버 엔지니어링

- 필요한 적정 수준보다 더 높은 수준의 엔지니어링
    - 구현체가 하나인 인터페이스
        - 인터페이스 형태가 아키텍처 이해에 도움을 주거나, 근시일 내로 구현체가 추가될 가능성이 있다면 ok
        - 구현체를 수정할때마다 인터페이스도 수정해야함
        - 코드 탐색에 영향을 줌, 애플리케이션이 비대해 짐
    - 너무 이른 추상화
        - 정보가 숨겨지기 떄문에 복잡도가 높아짐
        - 선대에 의도를 파악하기 어려워진다.

### 은탄환은 없다.

- 클린코드는 은탄환이 아니다
- 실무 : 2가지 줄다리기
    - 지속 가능한 소프트웨어의 품질 vs 기술 부채를 안고 가는 빠른 결과물
    - 기술 부채를 안고 가더라도 클린코드 사고법을 기반으로 결정하자
- 모든 기술과 방법론은 적정 기술의 범위 내에서 사용되어야 한다.
    - 당장 급한데 style관련 리뷰를 주고 고치라고 강요하는 사람
- 도구라는 것은, 일단 그것을 한계까지 사용할 줄 아는 사람이 그것을 사용하지 말아야 할 때도 아는 법이다.